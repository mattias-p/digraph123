#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# digraph123 - Play a random walk of a directed graph made of audio files.
# Copyright (C) 2016  Mattias Päivärinta
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import argparse
import os
import pygame
import random
import re
import sys
import textwrap

END_MUSIC_EVENT = pygame.USEREVENT + 0    # ID for music Event
ARROW_RE = re.compile('.*/([^-]+)-([^-]+)(?:-.*)?\.(?:ogg|mp3)', re.IGNORECASE)

def feedback(message):
    print(message, file=sys.stderr)

def fatal(message):
    feedback(message)
    sys.exit(1)

def path_files(path):
    if os.path.isfile(path):
        yield path
    elif os.path.isdir(path):
        for basename in os.listdir(path):
            f = os.path.join(path, basename)
            if os.path.isfile(f):
                yield f
    else:
        raise ValueError("neither file nor directory: '%s'" % path)

def file_arrow(path):
    m = ARROW_RE.match(path)
    if m:
        tail = m.group(1).lower()
        head = m.group(2).lower()
        yield tail, head, path

def add_arrow(graph, arrow):
    tail, head, path = arrow
    graph.setdefault(tail, []).append((head, path))
    graph.setdefault(head, [])
    return graph

def take(n, it):
    for i in range(0, n):
        yield it.next()

def walk(graph, node):
    while graph[node]:
        node, path = random.choice(graph[node])
        yield path

def play(playlist):
    try:
        path = playlist.next()
    except StopIteration:
        return

    pygame.mixer.music.load(path)
    pygame.mixer.music.play()

    pygame.event.post(pygame.event.Event(END_MUSIC_EVENT))
    while True:
        event = pygame.event.poll()
        if event.type == END_MUSIC_EVENT:
            if path:
                print(path)
            else:
                break
            try:
                path = playlist.next()
                pygame.mixer.music.queue(path)
            except StopIteration:
                path = None
        pygame.time.delay(100)

def muted(playlist):
    for path in playlist:
        print(path)

def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Play an audio recording shaped like a directed graph by means of random walk.",
        epilog=textwrap.dedent("""\
            file name format:
                The file name format matches the patterns TAIL-HEAD.EXT or
                TAIL-HEAD-DESCRIPTION.EXT. TAIL and HEAD are node labels. DESCRIPTION is
                ignored. EXT indicates the file format and is either `ogg` or `mp3`. HEAD,
                TAIL and EXT are case insensitive.

            operation:
                %(prog)s performs the following steps:

                 1. The *path* arguments are processed. An arrow going from the TAIL node to
                    the HEAD node is associated with each resulting file and a directed
                    graph (digraph) is constructed from the arrows.

                    Information about all the arrows are printed to stderr.

                 2. An initial *current node* is selected. If a node has been labeled
                    `start`, this node is selected. Otherwise, the tail node of a random
                    arrow is selected.

                 3. While the *current node* has at least one outgoing arrow, repeat:

                    1. A random outgoing arrow from the *current node* is selected.

                    2. The audio file associated with the selected arrow is played until it
                       ends. (Unless *--mute* is specified)

                       The path of the audio file is printed to stdout.

                    3. The head node of the selected arrow becomes the new *current node*.

                Terminate %(prog)s by pressing Ctrl+C.
        """),
    )
    parser.add_argument(
            '--mute',
            action='store_true',
            help="Don't play audio, just print audio file paths",
    )
    parser.add_argument(
            '--max',
            type=int,
            help="Maximum number of arrows to traverse",
    )
    parser.add_argument(
            'path',
            nargs='+',
            help="""\
                An audio file or a directory containing audio files. Audio files
                whose names don't match the *file name format* are ignored.""",
    )
    args = parser.parse_args()

    files = []
    for p in args.path:
        try:
            files.extend(path_files(p))
        except ValueError, e:
            parser.error(e)

    arrows = []
    for f in files:
        arrows.extend(file_arrow(f))

    if not arrows:
        fatal("no matching audio files found")

    twidth, hwidth = 0, 0
    for tail, head, _ in arrows:
        twidth = max(twidth, len(tail))
        hwidth = max(hwidth, len(head))

    graph = {}
    for a in sorted(arrows):
        feedback("found arrow: {:{twidth}} -> {:{hwidth}}  ({})".format(*a, twidth=twidth, hwidth=hwidth))
        graph = add_arrow(graph, a)

    if 'start' in graph:
        start = 'start'
    elif arrows:
        start = random.choice(arrows)[0]
    else:
        sys.exit(0)

    playlist = walk(graph, start)

    if args.max is not None:
        playlist = take(args.max, playlist)

    if args.mute:
        muted(playlist)
    else:
        pygame.init()
        pygame.mixer.music.set_endevent(END_MUSIC_EVENT)

        play(playlist)

        pygame.quit()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
