#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# digraph123 - Play a random walk of a directed graph made of audio files.
# Copyright (C) 2016  Mattias Päivärinta
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import pygame
import sys
import os
import re
import random
import argparse
import itertools

END_MUSIC_EVENT = pygame.USEREVENT + 0    # ID for music Event
ARROW_RE = re.compile('.*/([^-]+)-([^-]+)(?:-.*)?\.(?:ogg|mp3)', re.IGNORECASE)

def path_files(path):
    if os.path.isfile(path):
        yield path
    elif os.path.isdir(path):
        for root, dirs, files in os.walk(path):
            for f in files:
                yield os.path.join(root, f)
    else:
        raise "Neither file nor directory: '%s'" % path

def file_arrow(path):
    m = ARROW_RE.match(path)
    if m:
        tail = m.group(1).lower()
        head = m.group(2).lower()
        yield tail, head, path

def add_arrow(graph, arrow):
    tail, head, path = arrow
    graph.setdefault(tail, []).append((head, path))
    graph.setdefault(head, [])
    return graph

def take(n, it):
    for i in range(0, n):
        yield it.next()

def walk(graph, node):
    while graph[node]:
        node, path = random.choice(graph[node])
        yield path

def play(playlist):
    try:
        path = playlist.next()
    except StopIteration:
        return

    pygame.mixer.music.load(path)
    pygame.mixer.music.play()

    pygame.event.post(pygame.event.Event(END_MUSIC_EVENT))
    while True:
        event = pygame.event.poll()
        if event.type == END_MUSIC_EVENT:
            if path:
                print path
            else:
                break
            try:
                path = playlist.next()
                pygame.mixer.music.queue(path)
            except StopIteration:
                path = None
        pygame.time.delay(100)

def muted(playlist):
    for path in playlist:
        print path

def main():
    parser = argparse.ArgumentParser(
            description="Play a random walk of a directed graph made of audio files",
            epilog="Terminate %(prog)s by pressing Ctrl+C",
    )
    parser.add_argument(
            '--mute',
            action='store_true',
            help="Don't play audio, just print audio files",
    )
    parser.add_argument(
            '--max',
            type=int,
            help="Maximum number of arrows to traverse",
    )
    parser.add_argument(
            'path',
            nargs='*',
            help="An audio file or a directory containing audio files",
    )
    args = parser.parse_args()

    files = []
    for p in args.path:
        files.extend(path_files(p))

    arrows = []
    for f in files:
        arrows.extend(file_arrow(f))

    graph = {}
    for a in arrows:
        graph = add_arrow(graph, a)

    if 'start' in graph:
        start = 'start'
    elif arrows:
        start = random.choice(arrows)[0]
    else:
        sys.exit(0)

    playlist = walk(graph, start)

    if args.max is not None:
        playlist = take(args.max, playlist)

    if args.mute:
        muted(playlist)
    else:
        pygame.init()
        pygame.mixer.music.set_endevent(END_MUSIC_EVENT)

        play(playlist)

        pygame.quit()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
